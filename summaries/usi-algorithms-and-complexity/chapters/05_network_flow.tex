% !TEX root = ../algo-summary.tex

\section{Network Flow}\label{sec:network_flow}

restricted version of a more general optimization problem, called linear programming.

\begin{definition}[Flow Network]\label{def:flow_network}
Abstraction for stuff \emph{flowing} through the edges of a network.
A flow network is a directed graph \(G = (V, E)\) with a \emph{source} and a \emph{sink} node \(s, t \in V\) (where flow originates and is consumed, respectively),
Each edge \((u,v) \in E\) has a capacity \(c(u,v) \in \N_0\), where \(c(u,v) = 0\) if \((u,v) \notin E\).
\end{definition}

\begin{remark}
Multiple sources/sinks can be modeled by adding a \emph{super-source} and \emph{super-sink} with infinite capacity.
\end{remark}

\begin{caution}
If we have further restrictions, such as flow from certain sources can only go to certain sinks, we have the \emph{multi-commodity flow problem}, which is NP-hard.
\end{caution}

\subsection{Flows and Cuts}\label{sec:flows_cuts}

Two rich algorithmic problems with a beautiful duality. 
Cornerstones in combinatorial optimization.


\begin{definition}[Flow]\label{def:flow}
A \emph{\(s\)-\(t\) flow} is a function \(f : E \to \R_{\ge 0}\) that satisfies
\begin{itemize}
  \item \emph{Capacity:} For each \(e \in E\)
  \begin{equation}\label{eq:capacity_constraints}
    0 \le f(e) \le c(e)
  \end{equation}
  \item \emph{Conservation:} For each \(v \in V \setminus \{s,t\}\)
  \begin{equation}\label{eq:flow_conservation}
    \sum_{u \in V} f(u,v) = \sum_{w \in V} f(v,w)
  \end{equation}
\end{itemize}
where \(s, t \in V\) are the source and sink nodes.
\end{definition}
\begin{definition}\label{def:flow_value}
The \emph{value} \(v(f)\) (also denoted by \(|f|\)) of a flow \(f\) is
\begin{equation}\label{eq:flow_value}
  {\color{Red}\boxed{\color{black}
  v(f) \coloneqq \sum_{w \in V} f(s,w) = \sum_{u \in V} f(u,t)
  }}
\end{equation}
where equality follows from flow conservation.
\end{definition}

\begin{problem}[Max Flow]\label{prob:max_flow}
Find an \(s\)-\(t\) flow \(f\) of maximum value \eqref{eq:flow_value}.
\end{problem}

% \begin{remark}
% If all capacities \(c(u,v)\) are integers, there always exists a maximum flow \(f\) such that all \(f(u,v)\) are integers.
% \end{remark}




\begin{definition}\label{def:cut}
An \emph{\(s\)-\(t\) cut} is a partition \((A,B)\) of \(V\) with \(s \in A\) and \(t \in B = V \setminus A\).
\end{definition}
\begin{definition}
[Cut Capacity]
\label{def:cut_capacity}
The \emph{capacity} of the cut is
  \begin{equation}\label{eq:cut_capacity}
  {\color{Red}\boxed{\color{black}
    c(A,B) \coloneqq \sum_{a \in A} \sum_{b \in B} c(a,b)
  }}  
  \end{equation}
i.e. the summation of all edges going from \(A\) to \(B\).
\end{definition}

\begin{problem}[Min Cut]\label{prob:min_cut}
Find an \(s\)-\(t\) cut \((A,B)\) of minimum capacity \eqref{eq:cut_capacity}.
\end{problem}





\begin{definition}\label{def:cut_flow}
The \emph{net flow} across the cut is
  \begin{equation}\label{eq:cut_flow}
  {\color{Red}\boxed{\color{black}
  f(A,B)
  \coloneqq 
  % \sum_{u \in A, v \in B} f(u,v) - \sum_{u \in B, v \in A} f(u,v) 
  \sum_{u \in A} \sum_{v \in B} f(u,v) - \sum_{u \in B} \sum_{v \in A} f(u,v)
  }}
  \qedhere
  \end{equation}
\end{definition}



\begin{lemma}[Flow Value]\label{lem:flow_value}
Let \(f\) be any flow and \((A,B)\) be any cut. Then
\begin{equation}\label{eq:flow_value_cut}
  f(A,B)
  = 
  v(f)
\end{equation}
i.e. the \hl[2]{net flow across any cut equals the amount leaving \(s\)}. %value of the flow.
\end{lemma}
\begin{proof}
\[
\begin{verticalhack}
\begin{aligned}
  v(f) &\overset{\text{\eqref{eq:flow_value}}}{=} \sum_{v \in V} f(s,v) \\
       &=\sum_{v \in V} f(s,v) + 0 \\
       &\overset{\text{\eqref{eq:flow_conservation}}}{=} \sum_{v \in V} f(s,v) + \sum_{u \in A \setminus \{s\}} \left( \sum_{v \in V} f(u,v) - \sum_{v \in V} f(v,u) \right) \\
        &= \sum_{u \in A} \left( \sum_{v \in V} f(u,v) - \sum_{v \in V} f(v,u) \right) \\
       &= \sum_{u \in A} \sum_{v \in V} f(u,v) - \sum_{u \in A} \sum_{v \in V} f(v,u) \\
        &= \sum_{u \in A} \left( \sum_{v \in A} f(u,v) + \sum_{v \in B} f(u,v) \right) - \sum_{u \in A} \left( \sum_{v \in A} f(v,u) + \sum_{v \in B} f(v,u) \right) \\
        &= \cancel{\sum_{u \in A} \sum_{v \in A} f(u,v)} + \sum_{u \in A} \sum_{v \in B} f(u,v) - \cancel{\sum_{u \in A} \sum_{v \in A} f(v,u)} - \sum_{u \in A} \sum_{v \in B} f(v,u) \\
        &= \sum_{u \in A} \sum_{v \in B} f(u,v) - \sum_{u \in B} \sum_{v \in A} f(u,v) \\
        &= f(A,B) 
\end{aligned}
\end{verticalhack}
\qedhere
\]
\end{proof}




\begin{theorem}
[Weak Duality]
\label{lem:weak_duality_flow_capacity}
Let \(f\) be any flow and \((A,B)\) be any cut. Then
\begin{equation}\label{eq:weak_duality}
{\color{Red}\boxed{\color{black}
  v(f) \le c(A,B)
}}
\end{equation}
i.e. the value of the flow is at most the capacity of the cut.
\end{theorem}

\begin{proof}\label{proof:weak_duality}
\[
\begin{verticalhack}
\begin{aligned}
  v(f) 
  \overset{\text{\eqref{eq:flow_value_cut}}}{=} f(A,B) 
  \overset{\text{\eqref{eq:cut_flow}}}{=}& \sum_{u \in A} \sum_{v \in B} f(u,v) - \sum_{u \in B} \sum_{v \in A} f(u,v) \\
  \le& \sum_{u \in A} \sum_{v \in B} f(u,v) \\
  \overset{\text{\eqref{eq:capacity_constraints}}}{\le}& \sum_{u \in A} \sum_{v \in B} c(u,v) \\
  \overset{\text{\eqref{eq:cut_capacity}}}{=}& c(A,B)
\end{aligned}
\end{verticalhack}
\qedhere
\]
\end{proof}
\begin{corollary}[Certificate of Optimality]\label{cor:certificate_optimality}
\hl{Let \(f\) be any flow and \((A,B)\) be any cut.
If \(v(f) = c(A,B)\), then \(f\) is a \nameref{prob:max_flow} and \((A,B)\) is a \nameref{prob:min_cut}.}
\end{corollary}
\begin{observation}
\label{obs:flow_equals_cut_flow}
In addition, if \(v(f) = c(A,B)\), then
\begin{equation}\label{eq:max_flow_in}
f_{\text{in}}(A) \coloneqq  \sum_{u \in B} \sum_{v \in A} f(u,v) = 0
\end{equation}
and
\begin{equation}\label{eq:max_flow_out}
f_{\text{out}}(A) \coloneqq  \sum_{u \in A} \sum_{v \in B} f(u,v) = v(f) = c(A,B)
\end{equation}
i.e. all edges from \(A\) to \(B\) are saturated and all edges from \(B\) to \(A\) carry zero flow.
\end{observation}
\begin{proof}
From the \autoref{proof:weak_duality} of \autoref{lem:weak_duality_flow_capacity}, we have
\[
v(f) = f_{\text{out}}(A) - f_{\text{in}}(A) \le f_{\text{out}}(A) \le c(A,B)
\]
but if \(v(f) = c(A,B)\), all inequalities must be equalities, yielding \eqref{eq:max_flow_in} and \eqref{eq:max_flow_out}.
\end{proof}


\begin{caution}
  \nameref{sec:dynamic_programming} (\autoref{sec:dynamic_programming}) cannot be applied because the problem does not exhibit optimal substructure (\autoref{def:principle_of_optimality}).
\end{caution}

A na\"ive greedy strategy (\autoref{sec:greedy_algorithms}) will not work for \nameref{prob:max_flow} either, because local optimality does not imply global optimality.
This happens, because once we send flow along an edge, we might later want to ``take it back'' to reroute it more efficiently, so in addition to increase flow along edges, we need the ability to \emph{reduce} it as well.

We need the notion of a




\subsection{Residual Network}\label{sec:residual_network}

Recall the transpose graph \(G^\top = (V, E^\top)\), where \(E^\top = \{(v,u) \mid (u,v) \in E\}\).

In order to ``undo'' flow sent along edges, we consider original edges \(E\) (`forward arcs') as well as transpose edges \(E^\top\) (`backward arcs'), with capacities defined as follows.
Given flow \(f\), the \emph{residual capacity} of any arc is
\begin{equation}\label{eq:residual_capacity}
c_f(e) =
\begin{cases}
  c(e) - f(e) & e \in E \\
  f(e^R) & e \in E^\top
\end{cases}
\end{equation}
% where \(e^{R} = (u,v)\) denotes the original (forward) arc for a given backward arc \(e = (v,u) \in E^\top\).
where for any arc $a=(x,y)$ we define $a^R\coloneqq (y,x)$.
Note that if $e\in E^\top$, then $e^R\in E$.

\begin{definition}[Residual Network]\label{def:residual_network}
The \emph{residual network} \(G_f = (V, E_f)\) with respect to flow \(f\) contains the same vertices as \(G\) with the arc set
\begin{equation}\label{eq:residual_edges}
  E_f \coloneqq  \{ e \in E : f(e) < c(e) \} \cup \{ e \in E^\top: f(e^R) > 0 \}
\end{equation}
i.e., it contains all (forward and backward) arcs with positive residual capacity.
\end{definition}

Each edge in \(G\) may result in the generation of at most two arcs in \(G_f\).
Thus, \(G_f\) is of the same asymptotic size as \(G\).
% Also note that when \(v(f) = 0\), we have \(G_f = G\). % only true if there is no cycle
Note that when \(f \equiv 0\), we have \(G_f = G\).



\begin{definition}[Augmenting Path]\label{def:augmenting_path}
An \emph{augmenting path} is a simple \(s\)-\(t\) path \(P\) in the residual network \(G_f\).
\end{definition}

The \emph{bottleneck capacity} (also called {residual capacity}) of an \nameref{def:augmenting_path} \(P\) is
\begin{equation}\label{eq:augmenting_path_capacity}
  {\color{Red}\boxed{\color{black}
  c_f(P) \coloneqq \min_{e \in P} c_f(e)
  }}
\end{equation}
where the minimum is taken over all arcs on the path \(P\).
Since all arcs in \(P\) have positive residual capacity, \(c_f(P) > 0\).


% ```
% Augment(f, c, P) {
%     b \leftarrow bottleneck-capacity(P)
%     foreach e \in P {
%         if (e \in E) f(e) \leftarrow f(e) + b
%         else f(eR) \leftarrow f(e) - b
%     }
%     return f
% }
% ```

% forward edge reverse edge
% ```
% Ford-Fulkerson(G, s, t, c) {
%     foreach e \in E f(e) \leftarrow 0
%     Gf \leftarrow residual graph
%     while (there exists an augmenting path P in }\mp@subsup{G}{f}{}\mathrm{ )
% {
%         f \leftarrow Augment (f, c, P) //Augment f by cap(P)
%         update }\mp@subsup{G}{f}{
%     }
%     return f
% }
% ```

\begin{algorithm}[h]
\caption{Augment}\label{alg:augment}
\begin{algorithmic}[1]
\Function{Augment}{\(f, c, P\)}
\State \(b \gets c_f(P)\) \Comment{bottleneck capacity \eqref{eq:augmenting_path_capacity}}
\ForAll{\(e \in P\)}
  \If{\(e \in E\)}
     \State \(f(e) \gets f(e) + b\) \Comment{forward arc: increase flow}
  \Else  \Comment{\(e \in E^\top\)}
     \State \(f(e^R) \gets f(e^R) - b\) \Comment{backward arc: decrease flow along original edge}
  \EndIf
\EndFor
\State \Return \(f\)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Ford-Fulkerson Method}\label{alg:ford_fulkerson}
\begin{algorithmic}[1]
\Require Flow network \(G = (V,E)\), source \(s\), sink \(t\), capacities \(c\)
\ForAll{\(e \in E\)} 
 \State \(f(e) \gets 0\) \Comment{initial flow}
\EndFor
\State \(G_f \gets G\) \Comment{since the initial flow $f\equiv 0$, the initial residual network equals $G$}
% \While{\(\exists P \subset G_f\)} \Comment{there is an \nameref{def:augmenting_path} in \nameref{def:residual_network}}
 \While{there exists an \nameref{def:augmenting_path} \(P\) in \nameref{def:residual_network} \(G_f\)}
  \State \(f \gets \Call{Augment}{f, c, P}\) \Comment{augment flow along \(P\)}
  \State Update \(G_f\) based on new flow \(f\)
\EndWhile
\State \Return \(f\)
\end{algorithmic}
\end{algorithm}






At the end of the \autoref{alg:ford_fulkerson}, the \nameref{def:residual_network} \(G_f\) contains no \nameref{def:augmenting_path}s.








\subsection{Max-Flow Min-Cut Theorem}\label{sec:max_flow_min_cut_theorem}


\begin{theorem}[Augmenting Path]\label{thm:augmenting_path}
Flow \(f\) is a \nameref{prob:max_flow} iff there are no \nameref{def:augmenting_path}s in the \nameref{def:residual_network} \(G_f\).
\end{theorem}

\begin{theorem}[\nameref{prob:max_flow} / \nameref{prob:min_cut}, Ford-Fulkerson 1956]
The value of the \nameref{prob:max_flow} is equal to the value of the \nameref{prob:min_cut}.
\end{theorem}




\begin{theorem}[\nameref{prob:max_flow} / \nameref{prob:min_cut}]\label{thm:max-flow-min-cut}
Let $f$ be a flow in \(G\).
The following 3 are equivalent:
\begin{enumerate}[label=\textbf{(\roman*)}, itemindent=0.25cm, labelsep=0.25cm]
  \item There is cut $(A,B)$ such that $v(f) = c(A,B)$.
  \label{thm:mcmc-tight-cut}
  \item $f$ is a \nameref{prob:max_flow} and $(A,B)$ is a \nameref{prob:min_cut}.
  \label{thm:mcmc-maxflow-mincut}
  \item The \nameref{def:residual_network} $G_f$ contains no \nameref{def:augmenting_path}s.
  \label{thm:mcmc-no-augmenting-path}
\qedhere
\end{enumerate}
\end{theorem}

\begin{proof}
We prove the implications in the following triangle:
\(
\newcommand{\scalefraction}{0.68}
\begin{tikzcd}[column sep={\scalefraction*1cm,between origins},
               row sep={\scalefraction*1.732050808cm,between origins},
               arrows=Rightarrow]
  & \ref{thm:mcmc-tight-cut}
    \arrow[dr,""{pos=.5,sloped,overlay, inner sep=0pt,
      label={[black]center:\hyperlink{proof:mcmc-1-2}{\phantom{\rule{10pt}{15pt}}}}}]
  &
  \\
  \ref{thm:mcmc-no-augmenting-path}
    \arrow[ur,""{pos=.5,sloped,overlay, inner sep=0pt,
      label={[black]center:\hyperlink{proof:mcmc-3-1}{\phantom{\rule{10pt}{15pt}}}}}]
  &
  &
  \ref{thm:mcmc-maxflow-mincut}
    \arrow[ll,""{pos=.5,sloped,overlay, inner sep=0pt,
      label={[black]center:\hyperlink{proof:mcmc-2-3}{\phantom{\rule{15pt}{5pt}}}}}]
\end{tikzcd}
\)

\vspace{-2\baselineskip}
\hypertarget{proof:mcmc-1-2}{
\underline{\ref{thm:mcmc-tight-cut} $\Rightarrow$ \ref{thm:mcmc-maxflow-mincut}:}}

\autoref{cor:certificate_optimality}.

\hypertarget{proof:mcmc-2-3}{
\underline{\ref{thm:mcmc-maxflow-mincut} $\Rightarrow$ \ref{thm:mcmc-no-augmenting-path} (contrapositive):}}

If there were an augmenting path in \(G_f\), we could improve \(f\) by sending flow along this path.


\hypertarget{proof:mcmc-3-1}{
\underline{\ref{thm:mcmc-no-augmenting-path} $\Rightarrow$ \ref{thm:mcmc-tight-cut}:}}

Let \(A\) be the set of vertices reachable from the source \(s\) in \(G_f\).
By construction, \(s \in A\).
Since \(G_f\) contains no augmenting path, \(t \notin A\).
If we set \(B = V \setminus A\), then \((A,B)\) is a cut.
%
We now want to show again that the inqualities
% \[
% v(f) = f_{\text{out}}(A) - f_{\text{in}}(A) \le f_{\text{out}}(A) \le c(A,B)
% \]
in the \autoref{proof:weak_duality} of \autoref{lem:weak_duality_flow_capacity} are actually equalities.
Let \(u \in A\) and \(v \in B\).
If \((u,v) \in E\), then \(f(u,v) = c(u,v)\) because otherwise \((u,v)\) would be in \(G_f\) and \(v\) would be in \(A\).
If \((v,u) \in E\), then \(f(v,u) = 0\) because otherwise \((u,v)\) would be in \(G_f\) and \(v\) would be in \(A\).

This closes the triangle of implications and proves \autoref{thm:max-flow-min-cut}.
\end{proof}


\begin{assumption}\label{ass:integer_capacities}
All capacities are integers between \(1\) and \(C\).
\end{assumption}

\begin{invariant}\label{inv:integer_flows}
Every flow value \(f(e)\) and every residual capacity \(c_f(e)\) remains an integer throughout the execution of \autoref{alg:ford_fulkerson}.
\end{invariant}

\begin{theorem}\label{thm:ford_fulkerson_iteration}
\autoref{alg:ford_fulkerson} terminates in at most \(v(f^*)\) iterations, where \(v(f^*) \leq nC\) is the value of a maximum flow.
\end{theorem}
\begin{proof}
Each \nameref{alg:augment} increases \(v(f)\) by at least 1 and \(v(f^*) \leq \deg^+(s) \cdot C \leq nC\).
\end{proof}

\begin{corollary}
\autoref{alg:ford_fulkerson} runs in time \(O(v(f^*) \cdot m)\) (not polynomial in \(n\)\textcolor{red}{!}), since an \nameref{def:augmenting_path} can be found in \(O(m)\) time.
\end{corollary}
\begin{corollary}
If \(C = 1\), \autoref{alg:ford_fulkerson} runs in \(O(n m)\) time.
\end{corollary}

\begin{theorem}[Integrality]\label{thm:integrality}
If all capacities are integers (\autoref{ass:integer_capacities}), there exists a \nameref{prob:max_flow}, such that \(f(e)\) is an integer for all \(e \in E\).
\end{theorem}
\begin{proof}
\autoref{alg:ford_fulkerson} terminates (\autoref{thm:ford_fulkerson_iteration}) and maintains \autoref{inv:integer_flows}.
\end{proof}

\begin{corollary}\label{cor:integral-flow-given-value}
If all capacities are integers (\autoref{ass:integer_capacities}) and there exists a  flow of value $k$, there exists an \emph{integral} flow of value $k$.
\end{corollary}
\begin{proof}
% Let $f^*$ be a \nameref{prob:max_flow}. By \autoref{thm:integrality}, $f^*$ is integral and $v(f^*) \ge k$.
Deleting $v(f^*)-k$ unit augmenting paths from an integral \nameref{prob:max_flow} $f^*$.
\end{proof}



\subsection{Choosing Augmenting Paths}\label{sec:choosing_augmenting_paths}

Running time of generic \nameref{alg:ford_fulkerson} is \emph{pseudo-polynomial}, not polynomial in size of the input \(n, m\).

\textcolor{AccentBlue}{Use care when selecting \nameref{def:augmenting_path}s}:
\begin{itemize}
  \item Some choices lead to exponential algorithms.
  \item Clever choices lead to polynomial algorithms (Edmonds-Karp).
  \item If capacities are irrational, may not terminate!
\end{itemize}




% \[
% \begin{tikzpicture}[
%   font=\footnotesize,
%   scale=0.6,
%   node/.style={circle, draw, minimum size=3mm, inner sep=0pt},
%   edge/.style={-latex},
%   path/.style={-latex, thick, draw=orange!90!red},
%   lbl/.style={midway, fill=white, inner sep=1pt}
% ]

% % nodes
% \node[node] (s) at (0,2) {$s$};
% \node[node] (a) at (-3,0) {};
% \node[node] (u) at (-1,0) {};
% \node[node] (v) at (1,0) {};
% \node[node] (b) at (3,0) {};
% \node[node] (t) at (0,-2) {$t$};

% % outer black diamond edges
% \draw[edge] (s) -- node[lbl] {$x$} (a);
% \draw[edge] (s) -- node[lbl] {$x$} (b);
% \draw[edge] (a) -- node[lbl] {$x$} (t);
% \draw[edge] (b) -- node[lbl] {$x$} (t);

% % inner black edges
% \draw[edge] (u) -- node[lbl] {$1$} (a);
% \draw[edge] (b) -- node[lbl] {$\phi$} (v);

% % highlighted orange path
% \draw[path] (s) -- node[lbl] {$x$} (u);
% \draw[path] (u) -- node[lbl] {$1$} (v);
% \draw[path] (v) -- node[lbl] {$x$} (t);

% \end{tikzpicture}
% \]

\begin{example}[Uri Zwick, 1993]\label{ex:zwick_network}
Consider the following network
\[
\begin{tikzpicture}[
  font=\footnotesize,
  scale=0.5,
  node/.style={circle, draw, minimum size=3mm, inner sep=0pt},
  smallnode/.style={circle, draw, minimum size=2mm, inner sep=0pt},
  edge/.style={-latex},
  path/.style={-latex, thick, draw=orange!90!red},
  lbl/.style={midway, fill=white, inner sep=1pt}
]

%======================
% TOP NETWORK + PATH
%======================

% nodes
\node[node] (s) at (0,2) {$s$};
\node[node] (a) at (-3,0) {};
\node[node] (u) at (-1,0) {};
\node[node] (v) at (1,0) {};
\node[node] (b) at (3,0) {};
\node[node] (t) at (0,-2) {$t$};

% % start / sink arrows
% \draw[edge] (0,3) -- (s);
% \draw[edge] (t) -- (0,-3);

% outer black diamond edges
\draw[edge] (s) -- node[lbl] {$x$} (a);
\draw[edge] (s) -- node[lbl] {$x$} (b);
\draw[edge] (a) -- node[lbl] {$x$} (t);
\draw[edge] (b) -- node[lbl] {$x$} (t);

% inner black edges
\draw[edge] (u) -- node[lbl] {$1$} (a);
\draw[edge] (b) -- node[lbl] {$\phi$} (v);

% highlighted orange path (s -> u -> v -> t)
\draw[path] (s) -- node[lbl] {$x$} (u);
\draw[path] (u) -- node[lbl] {$1$} (v);
\draw[path] (v) -- node[lbl] {$x$} (t);

%======================
% HELPER: base graph (no labels)
%======================

\newcommand{\basegraph}[6]{%
  % #1..#6 are node names: S A U V B T

  % nodes
  \node[smallnode] (#1) at (0,2) {};
  \node[smallnode] (#2) at (-3,0) {};
  \node[smallnode] (#3) at (-1,0) {};
  \node[smallnode] (#4) at (1,0) {};
  \node[smallnode] (#5) at (3,0) {};
  \node[smallnode] (#6) at (0,-2) {};

  % % edge
  % \draw[edge] (#1) -- (#2);
  % \draw[edge] (#1) -- (#5);
  % \draw[edge] (#2) -- (#6);
  % \draw[edge] (#5) -- (#6);

  % \draw[edge] (#3) -- (#2);
  % \draw[edge] (#5) -- (#4);
  % \draw[edge] (#1) -- (#3);
  % \draw[edge] (#3) -- (#4);
  % \draw[edge] (#4) -- (#6);
}

%======================
% BOTTOM: PATH A
%======================

\begin{scope}[scale= 0.7, yshift=-7.25cm, xshift=-9cm]
  \basegraph{sA}{aA}{uA}{vA}{bA}{tA}

  % orange path A: top -> left side -> u -> v -> bottom
  \draw[path] (sA) -- (aA);
  \draw[path] (aA) -- (uA);
  \draw[path] (uA) -- (vA);
  \draw[path] (vA) -- (tA);

  % other edges
  \draw[edge] (sA) -- (bA);
  \draw[edge] (sA) -- (uA);
  \draw[edge] (bA) -- (vA);
  \draw[edge] (aA) -- (tA);
  \draw[edge] (bA) -- (tA);

  \node at (2.75,-1.75) {$P_A$};
\end{scope}

%======================
% BOTTOM: PATH B
%======================

\begin{scope}[scale= 0.7, yshift=-7.25cm]
  \basegraph{sB}{aB}{uB}{vB}{bB}{tB}

  % orange path B: top -> right side -> v -> u -> left side -> bottom
  \draw[path] (sB) -- (bB);
  \draw[path] (bB) -- (vB);
  \draw[path] (vB) -- (uB);
  \draw[path] (uB) -- (aB);
  \draw[path] (aB) -- (tB);

  % other edges
  \draw[edge] (sB) -- (aB);
  \draw[edge] (sB) -- (uB);
  \draw[edge] (vB) -- (tB);
  \draw[edge] (bB) -- (tB);

  \node at (2.75,-1.75) {$P_B$};
\end{scope}

%======================
% BOTTOM: PATH C
%======================

\begin{scope}[scale= 0.7, yshift=-7.25cm, xshift=9cm]
  \basegraph{sC}{aC}{uC}{vC}{bC}{tC}

  % orange path C: top -> u -> v -> right side -> bottom
  \draw[path] (sC) -- (uC);
  \draw[path] (uC) -- (vC);
  \draw[path] (vC) -- (bC);
  \draw[path] (bC) -- (tC);

  % other edges
  \draw[edge] (sC) -- (aC);
  \draw[edge] (sC) -- (bC);
  \draw[edge] (uC) -- (aC);
  \draw[edge] (aC) -- (tC);
  \draw[edge] (vC) -- (tC);

  \node at (2.75,-1.75) {$P_C$};
\end{scope}

\end{tikzpicture}
\]
where \(\phi = \frac{\sqrt{5} - 1}{2} \approx 0.618\) denotes the golden ratio, satisfying \(\phi^2 + \phi = 1\).
\end{example}


Goal: Choose augmenting paths so that:
\begin{itemize}
  \item can find augmenting paths efficiently
  \item result in few iterations
\end{itemize}

\medskip

Strategies:
\begin{itemize}
  \item max bottleneck capacity (dependency on \(C\))
  \item sufficiently large bottleneck capacity \textcolor{AccentGray}{[Dinitz 1970]}. reduce dependency on \(C\) to \(\log C\). Time \(O(m^2 \log C)\).
  \item simple idea: \\
  don't do anything fancy with capacities, just choose the path with fewest number of edges \textcolor{AccentGray}{[Edmonds-Karp 1972]}. Polynomial time algorithm. Time \(O(n m^2)\).
\end{itemize}


\subsubsection{Edmonds-Karp}

\emph{Idea}: Always choose an augmenting path with the \hl{minimum number of edges} in the residual network.

\begin{itemize}
  \item Implemented by running \nameref{alg:bfs} in \(G_f\)
  \item Each augmentation increases the shortest path distance
  \item Total number of iterations: \(O(nm)\), so total running time is \hl[2]{\(O(n m^2)\)}
\end{itemize}









\subsection{Applications}
\subsubsection{Bipartite Matching}\label{sec:bipartite_matching}

\begin{definition}[Matching]\label{def:graph-matching}
Given an undirected graph \(G = (V,E)\), \(M \subseteq E\) is a \emph{matching} if each node appears in at most one edge in \(M\).
\end{definition}

\begin{definition}[Bipartite Matching]\label{def:graph-bipartite-matching}
A \emph{bipartite matching} is a \nameref{def:graph-matching} in an undirected, bipartite graph \(G = (L \cup R, E)\).
\end{definition}

\begin{problem}[Max Bipartite Matching]\label{prob:max_bipartite_matching}
Find a \nameref{def:graph-bipartite-matching} of maximum cardinality.
\end{problem}

\textcolor{AccentBlue}{\nameref{prob:max_flow} formulation of \autoref{prob:max_bipartite_matching}}:
\begin{itemize}
  \item create digraph \(G' = (L \cup R \cup \{s,t\}, E')\)
  \item direct all edges from \(L\) to \(R\) and assign infinite (or unit) capacitiy
  \item add \textcolor{AccentRed}{unit capacity} edges from \(s\) to all nodes in \(L\)
  \item add \textcolor{AccentRed}{unit capacity} edges from all nodes in \(R\) to \(t\)
\end{itemize}

\begin{theorem}\label{thm:matching_flow_equivalence}
a bipartite graph \(G\) has a \nameref{def:graph-matching} of size \(k\) iff the network formulation \(G'\) has a flow of value \(k\).
\end{theorem}
or equivalently:
\begin{theorem}\label{thm:max_matching_via_max_flow}
max cardinality matching in \(G\) = value of \nameref{prob:max_flow} in \(G'\).
\end{theorem}

% \begin{proof}
% `\(\leq\)' (\(|M|=k\), then \(G'\) has a flow of value \(k\)):
% \begin{itemize}
%   \item 
%   given a max matching \(M\) of \(G\) with \(|M| = k\); 
%   consider a flow \(f\) that sends 1 unit along each edge in \(M\): 
%   \begin{itemize}
%     \item for each \((u,v) \in M\), set \(f(s,u) = 1\), \(f(u,v) = 1\), \(f(v,t) = 1\)
%     \item all other edges have flow \(f(e) = 0\)
%   \end{itemize}
%   \item \(f\) is a valid flow: consider a \(x \in L \cup R\):
%   \begin{itemize}
%     \item if \(x\) is incident to \(M\): \(f_{\text{in}}(x) = 1 = f_{\text{out}}(x)\) since \(M\) is a \nameref{def:graph-matching}
%     \item if \(x\) is not incident to \(M\): \(f_{\text{in}}(x) = 0 = f_{\text{out}}(x)\)
%   \end{itemize}
%   \item value of flow \(f\): \(v(f) = |M| = k \leq v(f^*)\), where \(f^*\) is a \nameref{prob:max_flow}
%   \qedhere
% \end{itemize}
% \end{proof}

% \begin{proof}
% `\(\geq\)' (\(v(f^*) \leq k = |M|\), where \(M\) is a max matching):
% \begin{itemize}
%   \item 
%   let \(f\) be a \nameref{prob:max_flow} in \(G'\) with value \(r = v(f) = v(f^*)\)
%   \item 
%   apply \nameref{thm:integrality} theorem:
%   \(r\) is integral, thus can assume \(f\) is \(\{0,1\}\)-valued
%   \item 
%   let \(M\) be the set of edges from \(L\) to \(R\) with \(f(e) = 1\).
%   \item 
%   \(v(f^*) = r\), thus \(r\) edges out of \(s\) carry flow 1; thus, \(r\) nodes in \(L\) are picked for \(M\); by conservation constraint, \(r\) incident \(L\)-\(R\) edges are picked. 
%   Thus, \(r \leq |M|\).
%   \item 
%   By the conservation constraint, no two edges out of one node \(x \in L\) can be picked in \(M\); thus, \(M\) is a \nameref{def:graph-matching}.
%   \qedhere
% \end{itemize}
% \end{proof}

\begin{proof}[``$\le$'']
Let $M$ be a max matching in $G$ with $|M|=k$. 
Define a flow $f$ in $G'$ by
\(f(s,u)=1\), \(f(u,v)=1\), \(f(v,t)=1\) 
for each \((u,v)\in M\),
and $f(e)=0$ for all other edges. 
Capacity constraints \eqref{eq:capacity_constraints} hold since all used edges have capacity at least \(1\).
For any vertex $x\in L\cup R$, 
either $x$ is incident to no edge of $M$ (then $f_{\mathrm{in}}(x) = f_{\mathrm{out}}(x)=0$), 
or to exactly one edge of $M$ (then $f_{\mathrm{in}}(x) = f_{\mathrm{out}}(x)=1$);
hence flow conservation \eqref{eq:flow_conservation} holds. 
Thus $f$ is a feasible flow in $G'$ and
\(
v(f)=\sum_{u\in L} f(s,u) = |M| = k
\).
In particular, if $f^*$ is a max flow in $G'$, then $v(f^*) \ge v(f) = k$.
\end{proof}

\begin{proof}[``$\ge$'']
Let $f$ be a max flow in $G'$ with $v(f) = r$. 
By integrality (\autoref{thm:integrality}), we may assume $f$ is integral, 
hence $f(e) \in \{0,1\}$ by capacity constraints \eqref{eq:capacity_constraints}.
Define
\(
M \coloneqq \{(u,v)\in E \mid u\in L, v\in R, f(u,v) = 1\}
\).
For each $u \in L$ we have $\sum_{v \in R} f(u,v) = f(s,u) \le 1$ by flow conservation \eqref{eq:flow_conservation} at $u$, 
so at most one edge of $M$ is incident to $u$.
Similarly, 
for each $v \in R$ we have $\sum_{u \in L} f(u,v) = f(v,t) \le 1$, so at most one edge of $M$ is incident to $v$.
Thus $M$ is a matching in $G$ and
\(
|M| = \sum_{u \in L} \sum_{v \in R} f(u,v) = \sum_{u \in L} f(s,u) = v(f) = r
\).
In particular, if $M^*$ is a max matching in $G$, then $|M^*| \ge |M| = r$.
\end{proof}

The edges of the matching are the ones that carry flow from \(L\) to \(R\).


\medskip


We reduced the problem `\nameref{prob:max_bipartite_matching}' to the known problem `\nameref{prob:max_flow}'.




\begin{definition}[Perfect Matching]\label{def:perfect_matching}
A matching \(M \subseteq E\) is perfect if each node appears in exactly one edge in \(M\).  
\end{definition}

A necessary condition for a \nameref{def:perfect_matching} in a bipartite graph is \(|L| = |R|\).

\medskip

\textcolor{AccentBlue}{To compute a perfect matching (if one exists), compute a max cardinality matching}:
\begin{itemize}
  \item if cardinality \( = n = |L| = |R|\), then the matching is perfect
  \item if cardinality \(< n\), then no perfect matching exists
\end{itemize}

\medskip

\hl{A cut with capacity \(< n\) provides a \emph{certificate} that no perfect matching exists!}

\begin{notation}[Neighborhood]\label{not:neighborhood}
For a subset \(S \subseteq G\) of nodes in a graph, we write 
\begin{equation}
  N(S) \coloneqq \bigcup_{u \in S} \Gamma(u) %= \{ v \in V : \exists u \in S \text{ with } (u,v) \in E \}
\end{equation}
for the set of nodes adjacent to at least one node in \(S\).
\end{notation}


\begin{observation}\label{obs:hall-necessity}
If a bipartite graph \(G = (L \cup R, E)\) has a \nameref{def:perfect_matching}, then \(|N(S)| \ge |S|\) for all subsets \(S \subseteq L\).
\end{observation}
\begin{proof}
Suppose \(G\) has a perfect matching.
Then each node in any \(S \subseteq L\) is matched to a different node in \(N(S)\).
Thus, \(|S| \le |N(S)|\).
\end{proof}

\begin{theorem}[Marriage \textcolor{AccentGray}{[Frobenius 1917, Hall 1935]}]\label{thm:hall-marriage}
Let \(G = (L \cup R, E)\) be a bipartite graph with \(|L| = |R|\).
Then, \(G\) has a perfect matching iff \(|N(S)| \ge |S|\) for all subsets \(S \subseteq L\).
\end{theorem}

\begin{proof}[`$\Rightarrow$']
\autoref{obs:hall-necessity}.
\end{proof}

% \begin{proof}[`$\Leftarrow$']
% Suppose G does not have a perfect matching 
% \begin{itemize}
% \item Formulate $\mathrm{G}^{\prime}$ as max flow problem and let $({A}, {B})$ be min cut in ${G}^{\prime}$.
% \item Since no perfect matching, $v\left(f^*\right)<n$ and $\operatorname{cap}({A}, {B})<{n}(|L|=n)$
% \item Define $L_A=L \cap A, L_B=L \cap B, R_A=R \cap A$.
% \item Since min cut can't use $\infty$ edges, no edge from $L$ to $R$ can be in cut; only edges from $s$ to $B\left(L_B\right)+$ edges from $A$ to $t\left(R_A\right)$
% \item Thus, $\operatorname{cap}(A, B)=\left|L_B\right|+\left|R_A\right|$. Similarly, $N\left(L_A\right) \subseteq R_A$.
% \item $\left|N\left(L_A\right)\right| \leq\left|R_A\right|=\operatorname{cap}(A, B)-\left|L_B\right|<|L|-\left|L_B\right|=\left|L_A\right|$.
% \item $\left|N\left(L_A\right)\right|<\left|L_A\right|$. Chose $S=L_A$.
% \qedhere
% \end{itemize}
% \end{proof}
\begin{proof}[`$\Leftarrow$']
We prove the contrapositive, i.e.
\[
\text{\(G\) has no perfect matching} \; \implies \; \exists S \subseteq L: |N(S)| < |S|
\]

Suppose \(G\) does not have a perfect matching 
\begin{itemize}
\item 
Formulate ${G}^{\prime}$ as \nameref{prob:max_flow} problem and let $({A}, {B})$ be \nameref{prob:min_cut} in ${G}^{\prime}$.
\item 
Since no perfect matching, 
value of \nameref{prob:max_flow} $v\left(f^*\right)<n$ (\autoref{thm:max_matching_via_max_flow})
and therefore (by \autoref{thm:max-flow-min-cut}),
capacity of the \nameref{prob:min_cut} $\operatorname{cap}({A}, {B})<{n}=|L|$.
\item 
Define $L_A=L \cap A$,  $L_B=L \cap B$, $R_A=R \cap A$, $R_B=R \cap B$.
\item 
Since \nameref{prob:min_cut} can't use $\infty$ edges (otherwise the cut capacity would be \(\infty\)), no edge from $L$ to $R$ can be in cut; 
only edges from $s$ to $B$ ($L_B$) and edges from $A$ to $t$ ($R_A$).
\item 
Since all these edges have unit capacity, $\operatorname{cap}(A, B)=\left|L_B\right|+\left|R_A\right|$. 
Furthermore, no edge from $L_A$ to $R_B$ implies $N\left(L_A\right) \subseteq R_A$.
\item 
$\left|N\left(L_A\right)\right| \leq\left|R_A\right|=\operatorname{cap}(A, B)-\left|L_B\right|<|L|-\left|L_B\right|=\left|L_A\right|$.
\item 
$\left|N\left(L_A\right)\right|<\left|L_A\right|$. 
Choose $S=L_A$.
\qedhere
\end{itemize}
\end{proof}

\bigskip

\textcolor{AccentBlue}{Which max flow algorithm to use for \nameref{def:graph-bipartite-matching}?}
\begin{itemize}
  \item Generic augmenting path: \(O(m \cdot \text{val}(f^*)) = O(mn)\), since \(\text{val}(f^*) \leq n\)
  \item \textcolor{gray}{Capacity scaling: \(O(m^2 \log C) = O(m^2)\)}
  \item Shortest augmenting path: \(O(m \sqrt{n})\)
\end{itemize}

\medskip

\textcolor{AccentBlue}{Non-bipartite \nameref{def:graph-matching}}:
\begin{itemize}
  \item Structure of non-bipartite graphs is more complicated, but well-understood \textcolor{AccentGray}{[Tutte-Berge, Edmonds-Galai]}
  \item Blossom algorithm: \(O(n^4)\) \textcolor{AccentGray}{[Edmonds 1965]}
  \item Best known: \(O(m \sqrt{n})\) \textcolor{AccentGray}{[Micali-Vazirani 1980]}
\end{itemize}



\subsubsection{Edge Disjoint Paths}\label{sec:edge_disjoint_paths}

\begin{definition}[Edge Disjoint Paths]\label{def:edge_disjoint_paths}
Two paths are \textcolor{AccentRed}{edge disjoint} if they have no edge in common.
\end{definition}

\begin{problem}[Max Edge Disjoint Paths]\label{prob:max_edge_disjoint_paths}
Given a directed graph \(G = (V,E)\) and two nodes \(s,t \in V\), find the maximum number of edge disjoint \(s\)-\(t\) paths.
\end{problem}

\textcolor{AccentBlue}{\nameref{prob:max_flow} formulation of \autoref{prob:max_edge_disjoint_paths}}:
assign unit capacity to each edge in \(G\).


\begin{theorem}\label{thm:max_edge_disjoint_paths_max_flow_equivalence}
\(G\) has \(k\) edge-disjoint \(s\)-\(t\) paths iff \(G'\) has a flow of value \(k\).
\end{theorem}

\begin{theorem}\label{thm:k_edge_disjoint_paths_k_flow_equivalence}
Max number of edge-disjoint \(s\)-\(t\) paths equals value of \nameref{prob:max_flow}.
\end{theorem}


\begin{proof}[``$\le$'']
Let \(P_1, \ldots, P_k\) be \(k\) edge disjoint \(s\)-\(t\) paths.
Create a flow \(f\) as follows:
Make each path \(P_i\) carry 1 unit of flow from \(s\) to \(t\),
i.e. set \(f(e) = 1\) if \(e\) participates in some path \(P_i\), and \(f(e) = 0\) otherwise.
Since the paths are edge disjoint, no edge carries more than 1 unit of flow,
so capacity constraints \eqref{eq:capacity_constraints} are satisfied.
Flow conservation \eqref{eq:flow_conservation} is satisfied since at an internal node, each path has exactly one incoming and one outgoing edge.
The value of the flow is \(v(f) = k\) (\(k\) edges out of \(s\) carry flow one unit of flow).
\end{proof}

\begin{proof}[``$\ge$'']
Let \(f\) be a flow of value \(k\).
By \nameref{thm:integrality}, there exists a 0-1 flow \(f\) of value \(k\).
Consider an edge \((s,u)\) with \(f(s,u) = 1\).
By flow conservation \eqref{eq:flow_conservation}, there exists an edge \((u,v)\) with \(f(u,v) = 1\).
Continue until reaching \(t\), always choosing a new edge with flow 1.
Once reaching \(t\) we found one path.
Remove all edges of this path from the graph and repeat \(k\) times.
We obtain \(k\) (not necessarily sim\tikzmark{simple}ple) edge disjoint \(s\)-\(t\) paths (one for each edge our of \(s\) with flow 1).
\end{proof}
\newcommand{\annotdropcycle}{0.5cm}  % how far below the text the note sits
\newcommand{\arrowpadcycle}{0.1cm}   % small offset between mark and arrow target
\begin{tikzpicture}[remember picture,overlay, font=\scriptsize]

  \node[anchor = north west] (note1) at ($(pic cs:simple)+(0.4,-\annotdropcycle)$) {can eliminate cycles to get simple paths if desired}; % depth arrow
  \draw[->, outer sep=0cm, inner sep=0cm] (note1.west) -- ($(pic cs:simple)+(0,-\arrowpadcycle)$);  % offset label

\end{tikzpicture}
% \vspace{\dimexpr\annotdrop-0.1cm\relax}


We reduced the problem `\nameref{prob:max_edge_disjoint_paths}' to the known problem `\nameref{prob:max_flow}'.





\subsubsection{Network Connectivity}\label{sec:network_connectivity}

\begin{definition}
A set of edges \(F \subseteq E\) \textcolor{AccentRed}{disconnects \(t\) from \(s\)} if all \(s\)-\(t\) paths use at least one edge in \(F\).
\end{definition}

\begin{problem}[Network Connectivity]\label{prob:network_connectivity}
Given a directed graph \(G = (V,E)\) and two nodes \(s,t \in V\), 
find the minimum number of edges whose removal disconnects \(t\) from \(s\).
\end{problem}

We can solve \autoref{prob:network_connectivity} by finding a \nameref{prob:min_cut} in a network with unit capacities on all edges.

\begin{theorem}[\textcolor{AccentGray}{[Menger, 1927]}]\label{thm:network_connectivity_max_edge_disjoint_paths_equivalence}
The max number of edge disjoint \(s\)-\(t\) paths is equal to the min number of edges whose removal disconnects \(t\) from \(s\).
\end{theorem}

Special case of \nameref{thm:max-flow-min-cut} (\autoref{thm:max-flow-min-cut}):
\begin{itemize}
  \item derive a \nameref{def:flow_network} with unit capacities
  \item min number of edges whose removal disconnects \(t\) from \(s\) = \nameref{prob:max_flow}
  \item max number of edge disjoint \(s\)-\(t\) paths = \nameref{prob:max_flow}
\end{itemize}


